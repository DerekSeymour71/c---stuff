//A non-empty array A consisting of N integers is given. 
//The product of triplet (P, Q, R) equates to A[P] * A[Q] * A[R] (0 ≤ P < Q < R < N).
//current result 66% https://app.codility.com/demo/results/trainingA9PQK7-EBQ/
#include <iostream> /* console stuff */
#include <cstdlib>  /* standard lib */
#include <string>
#include <cstring>
#include <limits>   
#include <vector>  /*when size of array not known, can use push_back, for example */
#include <sstream> /* string streams */
#include <numeric> /* sequences of values */
#include <ctime>   /* time, baby */
#include <cmath>   /* numbers, yo */
#include <assert.h>  /* assertions */
#include <functional>
#include <bits/stdc++.h>

using namespace std; 

void output(string str){
  cout<<str << endl;
}; 

//N is an integer within the range [3..100,000];
//each element of array A is an integer within the range [−1,000..1,000].

//this is a sorting problem, but doesn't have to be?


//4,6,1,8,9,3

//we can have three buckets, X,Y,Z and 3 indexes noting the order
//  X = 4
//  Y = 6   
//  Z = 1   least idx = 2

//then look at the rest, i.e. 8   where does 8 go? i.e. not in X, as Z is smaller


 


int solution(vector<int> &A){
  int X=-4000;
  int Y=-4000;
  int Z=-4000;
  int max=-4000;
  int positive_product=0;
  int negative_product=0;
  int MaxNegativeA=0;
  int MaxNegativeB=0;  
  int Size = A.size();
 
     for (int i = 0; i< Size; i++){ 
   
      if (A[i] < 0) { //put it into the negative buckets
      
        if ((A[i]<MaxNegativeA) || (A[i] < MaxNegativeB)) { 
         
          if ((A[i] < MaxNegativeA) & (MaxNegativeA > MaxNegativeB)) { 
            MaxNegativeA= A[i];
          }
          else { 
           MaxNegativeB = A[i];
          }
           
        }
      }
      else
      if ((A[i] > X) & (X<Y) & (X<Z)){ 
       
        X = A[i];
      } 
      else
      if ((A[i] > Y) & (Y<Z)){ 
        Y = A[i];
      }      
      else
      if (A[i] > Z) { 
        Z = A[i];
      }
      if (A[i] > max){ max = A[i];}
    }

   positive_product = X * Y * Z;

     if ((MaxNegativeA < 0) & (MaxNegativeB < 0)) { 
      
       negative_product = max * MaxNegativeA * MaxNegativeB;
     } 

     if (negative_product > positive_product){ 
       return negative_product;
     }
     else
     { 
       return positive_product;
     }
   


  //return X*Y*Z; this is wrong, forgot to take it out...it should still work but need to re-run it.

}


/* further analysis of problemo, man

five types of possible types of triplets, 3 possible positive + triplets

    positive triplets
    1   [ 1,   1,   1]     +   (A & B  +)    C +
    2   [-1,  -1,   1]     +   (A & B  -)    C +
    3   [-1,   1,  -1]     +   (A or B -)    C -


    negative triplets
    4   [ 1,   1,  -1]     -
    5   [-1,  -1,  -1]     -


  only interested in possible + triplets
  
  question becomes, when adding next number into bucket, what would make it bigger and what would make it smaller? (Also, where should it go?)

*/
